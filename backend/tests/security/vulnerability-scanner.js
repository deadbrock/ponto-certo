/**
 * üîç SCANNER DE VULNERABILIDADES AUTOMATIZADO
 * 
 * Sistema automatizado para detectar vulnerabilidades de seguran√ßa
 * em tempo real no sistema de ponto digital
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execSync } = require('child_process');

class VulnerabilityScanner {
  constructor() {
    this.vulnerabilities = [];
    this.warnings = [];
    this.recommendations = [];
    this.scanResults = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    };
    
    this.patterns = {
      // Padr√µes de vulnerabilidades conhecidas
      sqlInjection: [
        /query\s*\(\s*[`'"]\s*SELECT.*\$\{/gi,
        /query\s*\(\s*[`'"].*\+.*[`'"]/gi,
        /db\.query\s*\(\s*[`'"].*\$\{.*\}/gi
      ],
      xss: [
        /innerHTML\s*=.*req\./gi,
        /document\.write\s*\(.*req\./gi,
        /\$\{.*req\..*\}/gi
      ],
      hardcodedSecrets: [
        /password\s*[:=]\s*[`'"][^`'"]{8,}/gi,
        /secret\s*[:=]\s*[`'"][^`'"]{10,}/gi,
        /api[_-]?key\s*[:=]\s*[`'"][^`'"]{10,}/gi,
        /jwt[_-]?secret.*[`'"][^`'"]{10,}/gi
      ],
      weakCrypto: [
        /crypto\.createHash\s*\(\s*[`'"]md5[`'"]/gi,
        /crypto\.createHash\s*\(\s*[`'"]sha1[`'"]/gi,
        /bcrypt\.hash.*rounds?\s*:\s*[1-9][^0-9]/gi
      ],
      pathTraversal: [
        /path\.join\s*\(.*req\./gi,
        /fs\.readFile\s*\(.*req\./gi,
        /\.\.\//g
      ],
      commandInjection: [
        /exec\s*\(.*req\./gi,
        /spawn\s*\(.*req\./gi,
        /system\s*\(.*req\./gi
      ]
    };
  }

  /**
   * Executar scan completo de vulnerabilidades
   */
  async runCompleteScan(targetDir = './src') {
    console.log('üîç INICIANDO SCAN DE VULNERABILIDADES...');
    console.log('=====================================');
    
    const startTime = Date.now();
    
    try {
      // 1. Scan de c√≥digo fonte
      await this.scanSourceCode(targetDir);
      
      // 2. Scan de depend√™ncias
      await this.scanDependencies();
      
      // 3. Scan de configura√ß√µes
      await this.scanConfigurations();
      
      // 4. Scan de arquivos sens√≠veis
      await this.scanSensitiveFiles();
      
      // 5. Scan de permiss√µes
      await this.scanFilePermissions();
      
      // 6. Gerar relat√≥rio
      const report = this.generateReport();
      
      const executionTime = Date.now() - startTime;
      console.log(`\n‚è±Ô∏è Scan conclu√≠do em ${executionTime}ms`);
      
      return report;
      
    } catch (error) {
      console.error('‚ùå Erro durante scan:', error);
      throw error;
    }
  }

  /**
   * Scan de c√≥digo fonte
   */
  async scanSourceCode(targetDir) {
    console.log('\nüìÅ SCANNING C√ìDIGO FONTE...');
    
    const files = this.getJavaScriptFiles(targetDir);
    
    for (const filePath of files) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        await this.analyzeFile(filePath, content);
      } catch (error) {
        this.addWarning('FILE_READ_ERROR', `Erro ao ler arquivo: ${filePath}`, 'low');
      }
    }
    
    console.log(`‚úÖ Analisados ${files.length} arquivos`);
  }

  /**
   * Analisar arquivo individual
   */
  async analyzeFile(filePath, content) {
    const relativePath = path.relative(process.cwd(), filePath);
    
    // SQL Injection
    for (const pattern of this.patterns.sqlInjection) {
      const matches = content.match(pattern);
      if (matches) {
        this.addVulnerability(
          'SQL_INJECTION',
          `Poss√≠vel SQL Injection detectada em ${relativePath}`,
          'critical',
          {
            file: relativePath,
            patterns: matches,
            recommendation: 'Use prepared statements ou ORM com valida√ß√£o'
          }
        );
      }
    }

    // XSS
    for (const pattern of this.patterns.xss) {
      const matches = content.match(pattern);
      if (matches) {
        this.addVulnerability(
          'XSS',
          `Poss√≠vel XSS detectado em ${relativePath}`,
          'high',
          {
            file: relativePath,
            patterns: matches,
            recommendation: 'Sanitize entrada do usu√°rio antes de renderizar'
          }
        );
      }
    }

    // Hardcoded Secrets
    for (const pattern of this.patterns.hardcodedSecrets) {
      const matches = content.match(pattern);
      if (matches) {
        this.addVulnerability(
          'HARDCODED_SECRET',
          `Secret hardcoded detectado em ${relativePath}`,
          'critical',
          {
            file: relativePath,
            recommendation: 'Mova secrets para vari√°veis de ambiente'
          }
        );
      }
    }

    // Weak Cryptography
    for (const pattern of this.patterns.weakCrypto) {
      const matches = content.match(pattern);
      if (matches) {
        this.addVulnerability(
          'WEAK_CRYPTO',
          `Criptografia fraca detectada em ${relativePath}`,
          'high',
          {
            file: relativePath,
            patterns: matches,
            recommendation: 'Use algoritmos seguros (SHA-256, bcrypt com rounds >= 12)'
          }
        );
      }
    }

    // Path Traversal
    for (const pattern of this.patterns.pathTraversal) {
      const matches = content.match(pattern);
      if (matches) {
        this.addVulnerability(
          'PATH_TRAVERSAL',
          `Poss√≠vel Path Traversal em ${relativePath}`,
          'high',
          {
            file: relativePath,
            patterns: matches,
            recommendation: 'Valide e sanitize caminhos de arquivo'
          }
        );
      }
    }

    // Command Injection
    for (const pattern of this.patterns.commandInjection) {
      const matches = content.match(pattern);
      if (matches) {
        this.addVulnerability(
          'COMMAND_INJECTION',
          `Poss√≠vel Command Injection em ${relativePath}`,
          'critical',
          {
            file: relativePath,
            patterns: matches,
            recommendation: 'Evite executar comandos com entrada do usu√°rio'
          }
        );
      }
    }

    // Verifica√ß√µes espec√≠ficas
    await this.checkSpecificVulnerabilities(relativePath, content);
  }

  /**
   * Verifica√ß√µes espec√≠ficas do sistema
   */
  async checkSpecificVulnerabilities(filePath, content) {
    // JWT Secret fraco
    if (content.includes('jwt-secret-key') && !content.includes('process.env')) {
      this.addVulnerability(
        'WEAK_JWT_SECRET',
        `JWT secret fraco ou hardcoded em ${filePath}`,
        'critical',
        {
          file: filePath,
          recommendation: 'Use JWT secret forte e armazene em vari√°vel de ambiente'
        }
      );
    }

    // CORS mal configurado
    if (content.includes('cors') && content.includes('origin: "*"')) {
      this.addVulnerability(
        'INSECURE_CORS',
        `CORS mal configurado em ${filePath}`,
        'medium',
        {
          file: filePath,
          recommendation: 'Configure CORS com origins espec√≠ficos'
        }
      );
    }

    // Logs com dados sens√≠veis
    if (content.match(/console\.log.*(?:senha|password|cpf|token)/gi)) {
      this.addVulnerability(
        'SENSITIVE_DATA_LOGGING',
        `Poss√≠vel logging de dados sens√≠veis em ${filePath}`,
        'medium',
        {
          file: filePath,
          recommendation: 'Remova dados sens√≠veis dos logs'
        }
      );
    }

    // Valida√ß√£o de entrada ausente
    if (content.includes('req.body') && !content.includes('validate')) {
      this.addWarning(
        'MISSING_INPUT_VALIDATION',
        `Poss√≠vel falta de valida√ß√£o de entrada em ${filePath}`,
        'medium'
      );
    }
  }

  /**
   * Scan de depend√™ncias
   */
  async scanDependencies() {
    console.log('\nüì¶ SCANNING DEPEND√äNCIAS...');
    
    try {
      const packagePath = path.join(process.cwd(), 'package.json');
      if (!fs.existsSync(packagePath)) {
        this.addWarning('NO_PACKAGE_JSON', 'package.json n√£o encontrado', 'low');
        return;
      }

      const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      
      // Verificar depend√™ncias conhecidamente vulner√°veis
      const vulnerableDeps = {
        'lodash': ['< 4.17.21'],
        'axios': ['< 0.21.2'],
        'express': ['< 4.17.3'],
        'jsonwebtoken': ['< 8.5.1'],
        'bcrypt': ['< 5.0.1']
      };

      for (const [dep, vulnerableVersions] of Object.entries(vulnerableDeps)) {
        if (packageJson.dependencies?.[dep] || packageJson.devDependencies?.[dep]) {
          const version = packageJson.dependencies?.[dep] || packageJson.devDependencies?.[dep];
          
          // Verifica√ß√£o simplificada - em produ√ß√£o usaria biblioteca espec√≠fica
          if (version.includes('^') || version.includes('~')) {
            this.addWarning(
              'DEPENDENCY_VERSION_RANGE',
              `Depend√™ncia ${dep} usando range de vers√£o: ${version}`,
              'low'
            );
          }
        }
      }

      // Tentar executar npm audit (se dispon√≠vel)
      try {
        const auditResult = execSync('npm audit --json', { encoding: 'utf8' });
        const audit = JSON.parse(auditResult);
        
        if (audit.vulnerabilities && Object.keys(audit.vulnerabilities).length > 0) {
          this.addVulnerability(
            'NPM_VULNERABILITIES',
            `${Object.keys(audit.vulnerabilities).length} vulnerabilidades encontradas pelo npm audit`,
            'high',
            {
              recommendation: 'Execute npm audit fix para corrigir'
            }
          );
        }
      } catch (error) {
        this.addWarning('NPM_AUDIT_FAILED', 'N√£o foi poss√≠vel executar npm audit', 'low');
      }

    } catch (error) {
      this.addWarning('DEPENDENCY_SCAN_ERROR', 'Erro ao analisar depend√™ncias', 'medium');
    }
  }

  /**
   * Scan de configura√ß√µes
   */
  async scanConfigurations() {
    console.log('\n‚öôÔ∏è SCANNING CONFIGURA√á√ïES...');
    
    // Verificar .env files
    const envFiles = ['.env', '.env.local', '.env.production', '.env.development'];
    
    for (const envFile of envFiles) {
      const envPath = path.join(process.cwd(), envFile);
      if (fs.existsSync(envPath)) {
        const content = fs.readFileSync(envPath, 'utf8');
        
        // Verificar se .env est√° no .gitignore
        const gitignorePath = path.join(process.cwd(), '.gitignore');
        if (fs.existsSync(gitignorePath)) {
          const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');
          if (!gitignoreContent.includes('.env')) {
            this.addVulnerability(
              'ENV_NOT_IGNORED',
              `Arquivo ${envFile} pode n√£o estar no .gitignore`,
              'critical',
              {
                recommendation: 'Adicione .env* ao .gitignore'
              }
            );
          }
        }

        // Verificar secrets fracos
        if (content.match(/JWT_SECRET=.{1,20}$/m)) {
          this.addVulnerability(
            'WEAK_JWT_SECRET_ENV',
            'JWT_SECRET muito curto no arquivo de ambiente',
            'high',
            {
              recommendation: 'Use JWT secret com pelo menos 32 caracteres'
            }
          );
        }
      }
    }

    // Verificar configura√ß√µes do banco
    const dbConfigPath = path.join(process.cwd(), 'src', 'config', 'database.js');
    if (fs.existsSync(dbConfigPath)) {
      const content = fs.readFileSync(dbConfigPath, 'utf8');
      
      if (content.includes('ssl: false') || content.includes('ssl:false')) {
        this.addVulnerability(
          'DB_SSL_DISABLED',
          'SSL desabilitado na conex√£o do banco de dados',
          'high',
          {
            recommendation: 'Habilite SSL para conex√µes de banco em produ√ß√£o'
          }
        );
      }
    }
  }

  /**
   * Scan de arquivos sens√≠veis
   */
  async scanSensitiveFiles() {
    console.log('\nüîí SCANNING ARQUIVOS SENS√çVEIS...');
    
    const sensitiveFiles = [
      '.env',
      '.env.local',
      '.env.production',
      'config.json',
      'secrets.json',
      'private.key',
      'certificate.pem',
      'id_rsa',
      'id_dsa'
    ];

    const sensitivePatterns = [
      /.*\.key$/,
      /.*\.pem$/,
      /.*\.p12$/,
      /.*\.pfx$/,
      /.*private.*\.json$/,
      /.*secret.*\.json$/
    ];

    // Verificar arquivos espec√≠ficos
    for (const file of sensitiveFiles) {
      const filePath = path.join(process.cwd(), file);
      if (fs.existsSync(filePath)) {
        const stats = fs.statSync(filePath);
        
        // Verificar permiss√µes (Unix-like systems)
        if (process.platform !== 'win32') {
          const mode = stats.mode & parseInt('777', 8);
          if (mode & parseInt('044', 8)) { // Readable by group/others
            this.addVulnerability(
              'SENSITIVE_FILE_PERMISSIONS',
              `Arquivo sens√≠vel ${file} tem permiss√µes muito abertas`,
              'high',
              {
                recommendation: 'Altere permiss√µes para 600 (owner read/write only)'
              }
            );
          }
        }
      }
    }

    // Buscar por padr√µes de arquivos sens√≠veis
    const allFiles = this.getAllFiles(process.cwd());
    for (const filePath of allFiles) {
      const fileName = path.basename(filePath);
      
      for (const pattern of sensitivePatterns) {
        if (pattern.test(fileName)) {
          this.addWarning(
            'POTENTIAL_SENSITIVE_FILE',
            `Arquivo potencialmente sens√≠vel encontrado: ${fileName}`,
            'medium'
          );
        }
      }
    }
  }

  /**
   * Scan de permiss√µes de arquivos
   */
  async scanFilePermissions() {
    console.log('\nüîê SCANNING PERMISS√ïES...');
    
    if (process.platform === 'win32') {
      console.log('‚ö†Ô∏è Skip: Verifica√ß√£o de permiss√µes n√£o suportada no Windows');
      return;
    }

    const criticalFiles = [
      'src/config/database.js',
      'package.json',
      'server.js',
      'index.js'
    ];

    for (const file of criticalFiles) {
      const filePath = path.join(process.cwd(), file);
      if (fs.existsSync(filePath)) {
        const stats = fs.statSync(filePath);
        const mode = stats.mode & parseInt('777', 8);
        
        // Arquivos cr√≠ticos n√£o devem ser world-writable
        if (mode & parseInt('002', 8)) {
          this.addVulnerability(
            'WORLD_WRITABLE_FILE',
            `Arquivo cr√≠tico ${file} √© world-writable`,
            'medium',
            {
              recommendation: 'Remova permiss√£o de escrita para others'
            }
          );
        }
      }
    }
  }

  /**
   * Adicionar vulnerabilidade
   */
  addVulnerability(type, description, severity, details = {}) {
    this.vulnerabilities.push({
      type,
      description,
      severity,
      details,
      timestamp: new Date().toISOString()
    });
    
    this.scanResults[severity]++;
    
    const emoji = this.getSeverityEmoji(severity);
    console.log(`${emoji} ${severity.toUpperCase()}: ${description}`);
  }

  /**
   * Adicionar warning
   */
  addWarning(type, description, severity) {
    this.warnings.push({
      type,
      description,
      severity,
      timestamp: new Date().toISOString()
    });
    
    console.log(`‚ö†Ô∏è WARNING: ${description}`);
  }

  /**
   * Gerar relat√≥rio
   */
  generateReport() {
    const totalIssues = this.vulnerabilities.length + this.warnings.length;
    const criticalIssues = this.vulnerabilities.filter(v => v.severity === 'critical').length;
    
    // Calcular score de seguran√ßa
    let securityScore = 100;
    securityScore -= (this.scanResults.critical * 20);
    securityScore -= (this.scanResults.high * 10);
    securityScore -= (this.scanResults.medium * 5);
    securityScore -= (this.scanResults.low * 2);
    securityScore = Math.max(0, securityScore);

    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalIssues,
        criticalIssues,
        securityScore,
        status: this.getSecurityStatus(securityScore)
      },
      results: this.scanResults,
      vulnerabilities: this.vulnerabilities,
      warnings: this.warnings,
      recommendations: this.generateRecommendations()
    };

    this.printSummary(report);
    
    // Salvar relat√≥rio
    const reportPath = path.join(__dirname, `vulnerability-report-${Date.now()}.json`);
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    console.log(`\nüìÑ Relat√≥rio salvo em: ${reportPath}`);

    return report;
  }

  /**
   * Gerar recomenda√ß√µes
   */
  generateRecommendations() {
    const recommendations = [];

    if (this.scanResults.critical > 0) {
      recommendations.push({
        priority: 'CRITICAL',
        action: 'Corrigir imediatamente todas as vulnerabilidades cr√≠ticas',
        impact: 'Sistema pode estar comprometido'
      });
    }

    if (this.scanResults.high > 0) {
      recommendations.push({
        priority: 'HIGH',
        action: 'Corrigir vulnerabilidades de alta severidade',
        impact: 'Risco significativo de comprometimento'
      });
    }

    recommendations.push({
      priority: 'MEDIUM',
      action: 'Implementar Content Security Policy (CSP)',
      impact: 'Prote√ß√£o adicional contra XSS'
    });

    recommendations.push({
      priority: 'MEDIUM',
      action: 'Configurar headers de seguran√ßa (HSTS, X-Frame-Options)',
      impact: 'Prote√ß√£o contra ataques comuns'
    });

    recommendations.push({
      priority: 'LOW',
      action: 'Implementar monitoramento de seguran√ßa cont√≠nuo',
      impact: 'Detec√ß√£o precoce de amea√ßas'
    });

    return recommendations;
  }

  /**
   * Imprimir resumo
   */
  printSummary(report) {
    console.log('\nüõ°Ô∏è RELAT√ìRIO DE SEGURAN√áA');
    console.log('========================');
    console.log(`üìä Score de Seguran√ßa: ${report.summary.securityScore}/100 (${report.summary.status})`);
    console.log(`üö® Issues Cr√≠ticos: ${report.summary.criticalIssues}`);
    console.log(`üìã Total de Issues: ${report.summary.totalIssues}`);
    console.log('\nüìà BREAKDOWN:');
    console.log(`   üî¥ Critical: ${this.scanResults.critical}`);
    console.log(`   üü† High: ${this.scanResults.high}`);
    console.log(`   üü° Medium: ${this.scanResults.medium}`);
    console.log(`   üü¢ Low: ${this.scanResults.low}`);
    
    if (report.summary.criticalIssues > 0) {
      console.log('\nüö® A√á√ÉO IMEDIATA NECESS√ÅRIA!');
      console.log('   Vulnerabilidades cr√≠ticas detectadas.');
    }
  }

  // Fun√ß√µes auxiliares
  getJavaScriptFiles(dir) {
    const files = [];
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
        files.push(...this.getJavaScriptFiles(fullPath));
      } else if (stat.isFile() && (item.endsWith('.js') || item.endsWith('.ts'))) {
        files.push(fullPath);
      }
    }
    
    return files;
  }

  getAllFiles(dir) {
    const files = [];
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
        files.push(...this.getAllFiles(fullPath));
      } else if (stat.isFile()) {
        files.push(fullPath);
      }
    }
    
    return files;
  }

  getSeverityEmoji(severity) {
    const emojis = {
      critical: 'üî¥',
      high: 'üü†',
      medium: 'üü°',
      low: 'üü¢',
      info: 'üîµ'
    };
    return emojis[severity] || '‚ùì';
  }

  getSecurityStatus(score) {
    if (score >= 90) return 'EXCELLENT';
    if (score >= 80) return 'GOOD';
    if (score >= 70) return 'FAIR';
    if (score >= 50) return 'POOR';
    return 'CRITICAL';
  }
}

module.exports = VulnerabilityScanner;

// Executar scan se chamado diretamente
if (require.main === module) {
  const scanner = new VulnerabilityScanner();
  scanner.runCompleteScan()
    .then(report => {
      console.log('\n‚úÖ Scan de vulnerabilidades conclu√≠do!');
      process.exit(report.summary.criticalIssues > 0 ? 1 : 0);
    })
    .catch(error => {
      console.error('‚ùå Erro no scan:', error);
      process.exit(1);
    });
}
